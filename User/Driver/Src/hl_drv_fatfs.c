/**
 * @file hl_drv_fatfs.c
 * @author yijiujun (jiujun.yi@hollyland-tech.com)
 * @brief 
 * @version V1.0
 * @date 2022-12-20
 * 
 * ██╗  ██╗ ██████╗ ██╗     ██╗  ██╗   ██╗██╗      █████╗ ███╗   ██╗██████╗ 
 * ██║  ██║██╔═══██╗██║     ██║  ╚██╗ ██╔╝██║     ██╔══██╗████╗  ██║██╔══██╗
 * ███████║██║   ██║██║     ██║   ╚████╔╝ ██║     ███████║██╔██╗ ██║██║  ██║
 * ██╔══██║██║   ██║██║     ██║    ╚██╔╝  ██║     ██╔══██║██║╚██╗██║██║  ██║
 * ██║  ██║╚██████╔╝███████╗███████╗██║   ███████╗██║  ██║██║ ╚████║██████╔╝
 * ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝
 * @copyright Copyright (c) 2022 hollyland
 * 
 * @par 修改日志:
 * <table>
 * <tr><th>Date           <th>Version  <th>Author         <th>Description
 * <tr><td>2022-12-20     <td>v1.0     <td>yijiujun     <td>内容
 * </table>
 * 
 */
/* Define to prevent recursive inclusion -------------------------------------*/
/* Includes ------------------------------------------------------------------*/

#include "hl_drv_fatfs.h"
#include "hl_drv_flash.h"

/* typedef -------------------------------------------------------------------*/
/* define --------------------------------------------------------------------*/

#define debug_printf printf
#define FATFS_PATH "0:"  //文件系统的路径

#define FTAFS_SYSTEM_INFO_ADDR (FALSH_USE_OFFSET_SIZE)      //文件系统的引导扇区地址
#define FATFS_FAT1_ADDR (FALSH_USE_OFFSET_SIZE + 0x1000)    //文件系统的FAT1的地址
#define FATFS_FAT2_ADDR (FALSH_USE_OFFSET_SIZE + 0x2000)    //文件系统的FAT2的地址
#define FATFS_DIR_ADDR (FALSH_USE_OFFSET_SIZE + 0x3000)     //文件系统的目录扇区的地址

/* variables -----------------------------------------------------------------*/

static const char file_system_info[] = {
    0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x10, 0x01, 0x01, 0x00, 0x02, 0x00, 0x02,
    0xFE, 0x07, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x29, 0xC9, 0x22, 0x3B, 0x00, 0x4E, 0x4F, 0x20, 0x4E, 0x41, 0x4D, 0x45, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41, 0x54,
    0x31, 0x32, 0x20, 0x20, 0x20, 0x33, 0xC9, 0x8E, 0xD1, 0xBC, 0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E, 0xC0,
    0xFC, 0xBD, 0x00, 0x7C, 0x38, 0x4E, 0x24, 0x7D, 0x24, 0x8B, 0xC1, 0x99, 0xE8, 0x3C, 0x01, 0x72, 0x1C, 0x83, 0xEB,
    0x3A, 0x66, 0xA1, 0x1C, 0x7C, 0x26, 0x66, 0x3B, 0x07, 0x26, 0x8A, 0x57, 0xFC, 0x75, 0x06, 0x80, 0xCA, 0x02, 0x88,
    0x56, 0x02, 0x80, 0xC3, 0x10, 0x73, 0xEB, 0x33, 0xC9, 0x8A, 0x46, 0x10, 0x98, 0xF7, 0x66, 0x16, 0x03, 0x46, 0x1C,
    0x13, 0x56, 0x1E, 0x03, 0x46, 0x0E, 0x13, 0xD1, 0x8B, 0x76, 0x11, 0x60, 0x89, 0x46, 0xFC, 0x89, 0x56, 0xFE, 0xB8,
    0x20, 0x00, 0xF7, 0xE6, 0x8B, 0x5E, 0x0B, 0x03, 0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x46, 0xFC, 0x11, 0x4E, 0xFE, 0x61,
    0xBF, 0x00, 0x00, 0xE8, 0xE6, 0x00, 0x72, 0x39, 0x26, 0x38, 0x2D, 0x74, 0x17, 0x60, 0xB1, 0x0B, 0xBE, 0xA1, 0x7D,
    0xF3, 0xA6, 0x61, 0x74, 0x32, 0x4E, 0x74, 0x09, 0x83, 0xC7, 0x20, 0x3B, 0xFB, 0x72, 0xE6, 0xEB, 0xDC, 0xA0, 0xFB,
    0x7D, 0xB4, 0x7D, 0x8B, 0xF0, 0xAC, 0x98, 0x40, 0x74, 0x0C, 0x48, 0x74, 0x13, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0xCD,
    0x10, 0xEB, 0xEF, 0xA0, 0xFD, 0x7D, 0xEB, 0xE6, 0xA0, 0xFC, 0x7D, 0xEB, 0xE1, 0xCD, 0x16, 0xCD, 0x19, 0x26, 0x8B,
    0x55, 0x1A, 0x52, 0xB0, 0x01, 0xBB, 0x00, 0x00, 0xE8, 0x3B, 0x00, 0x72, 0xE8, 0x5B, 0x8A, 0x56, 0x24, 0xBE, 0x0B,
    0x7C, 0x8B, 0xFC, 0xC7, 0x46, 0xF0, 0x3D, 0x7D, 0xC7, 0x46, 0xF4, 0x29, 0x7D, 0x8C, 0xD9, 0x89, 0x4E, 0xF2, 0x89,
    0x4E, 0xF6, 0xC6, 0x06, 0x96, 0x7D, 0xCB, 0xEA, 0x03, 0x00, 0x00, 0x20, 0x0F, 0xB6, 0xC8, 0x66, 0x8B, 0x46, 0xF8,
    0x66, 0x03, 0x46, 0x1C, 0x66, 0x8B, 0xD0, 0x66, 0xC1, 0xEA, 0x10, 0xEB, 0x5E, 0x0F, 0xB6, 0xC8, 0x4A, 0x4A, 0x8A,
    0x46, 0x0D, 0x32, 0xE4, 0xF7, 0xE2, 0x03, 0x46, 0xFC, 0x13, 0x56, 0xFE, 0xEB, 0x4A, 0x52, 0x50, 0x06, 0x53, 0x6A,
    0x01, 0x6A, 0x10, 0x91, 0x8B, 0x46, 0x18, 0x96, 0x92, 0x33, 0xD2, 0xF7, 0xF6, 0x91, 0xF7, 0xF6, 0x42, 0x87, 0xCA,
    0xF7, 0x76, 0x1A, 0x8A, 0xF2, 0x8A, 0xE8, 0xC0, 0xCC, 0x02, 0x0A, 0xCC, 0xB8, 0x01, 0x02, 0x80, 0x7E, 0x02, 0x0E,
    0x75, 0x04, 0xB4, 0x42, 0x8B, 0xF4, 0x8A, 0x56, 0x24, 0xCD, 0x13, 0x61, 0x61, 0x72, 0x0B, 0x40, 0x75, 0x01, 0x42,
    0x03, 0x5E, 0x0B, 0x49, 0x75, 0x06, 0xF8, 0xC3, 0x41, 0xBB, 0x00, 0x00, 0x60, 0x66, 0x6A, 0x00, 0xEB, 0xB0, 0x42,
    0x4F, 0x4F, 0x54, 0x4D, 0x47, 0x52, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20,
    0x64, 0x69, 0x73, 0x6B, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x6D, 0x65, 0x64, 0x69,
    0x61, 0x2E, 0xFF, 0x0D, 0x0A, 0x44, 0x69, 0x73, 0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xFF, 0x0D, 0x0A, 0x50,
    0x72, 0x65, 0x73, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73,
    0x74, 0x61, 0x72, 0x74, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xCB, 0xD8, 0x55, 0xAA
};

static const char file_fat_info[] = { 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F };

static const char file_dir_info[] = { 0x42, 0x20, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x0F, 0x00,
                                      0x72, 0x72, 0x00, 0x6D, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00,
                                      0x00, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x01, 0x53, 0x00, 0x79, 0x00, 0x73, 0x00,
                                      0x74, 0x00, 0x65, 0x00, 0x0F, 0x00, 0x72, 0x6D, 0x00, 0x20, 0x00, 0x56, 0x00,
                                      0x6F, 0x00, 0x6C, 0x00, 0x75, 0x00, 0x00, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x53,
                                      0x59, 0x53, 0x54, 0x45, 0x4D, 0x7E, 0x31, 0x20, 0x20, 0x20, 0x16, 0x00, 0x9C,
                                      0xD0, 0x98, 0x29, 0x56, 0x29, 0x56, 0x00, 0x00, 0xD1, 0x98, 0x29, 0x56, 0x02 };


static FATFS fat_fs;  //文件系统

char work[FF_MAX_SS] = { 0 };  //一定是一个全局变量

static uint8_t _drv_init_flag = 0;

#if (FATFS_DRV_MKFS_FUN)
static MKFS_PARM mkfs_parm_st = {
    .fmt = FM_FAT | FM_SFD,
    .n_fat = 2,  //指定FAT/FAT32卷上的FAT副本数量。该成员的有效值为1或2。默认值(0)和任何invaid值都被视为1。
    .align   = 0,     //以扇区为单位，指定卷数据区域
    .n_root  = 512,   //根文件目录数量
    .au_size = 4096,  //文件分配单元大小，一个文件的大小
};
#endif

/* Private function(only *.c)  -----------------------------------------------*/

/**
 * @brief 将文件系统的配置信息，写入FALSH的对应的地址中
 * @date 2023-01-09
 * @author yijiujun (jiujun.yi@hollyland-tech.com)
 * @details 
 * @note 
 * @par 修改日志:
 * <table>
 * <tr><th>Date             <th>Author         <th>Description
 * <tr><td>2023-01-09      <td>yijiujun     <td>新建
 * </table>
 */
static void _fat12_flash_mkfs()
{
    uint32_t addr = 0x00;

    /* 写入引导扇区的配置信息，该为FAT12的配置 */
    memcpy(work, file_system_info, sizeof(file_system_info));
    hl_drv_flash_write(FTAFS_SYSTEM_INFO_ADDR, (uint8_t*)work, sizeof(work));

    /* 写入FAT1, FAT2的配置信息 */
    memset(work, 0, sizeof(work));
    memcpy(work, file_fat_info, sizeof(file_fat_info));
    hl_drv_flash_write(FATFS_FAT1_ADDR, (uint8_t*)work, sizeof(work));
    hl_drv_flash_write(FATFS_FAT2_ADDR, (uint8_t*)work, sizeof(work));

    /* 写入文件目录区的配置信息 */
    memset(work, 0, sizeof(work));
    memcpy(work, file_dir_info, sizeof(file_dir_info));
    hl_drv_flash_write(FATFS_DIR_ADDR, (uint8_t*)work, sizeof(work));

    /* 将文件目录区后面的放文件区域, 和最前面的几个数据区域置0 */
    memset(work, 0, sizeof(work));
    for (addr = FATFS_DIR_ADDR + FF_MAX_SS; addr < 14 * FF_MAX_SS; addr += FF_MAX_SS) {
        hl_drv_flash_write(addr, (uint8_t*)work, sizeof(work));
    }
}

/* Exported functions --------------------------------------------------------*/

int hl_drv_fatfs_init(FATFS* fs)
{
    FRESULT res_flash;  //文件操作结果

    if (_drv_init_flag == 1) {
        debug_printf("[erro] fatfs already init\r\n");
        return FATFS_FUN_RET_ERR;
    }
    res_flash = f_mount(&fat_fs, FATFS_PATH, 1);

    if (res_flash == FR_NO_FILESYSTEM) {
#if (FATFS_DRV_MKFS_FUN)
        /* 格式化 */
        res_flash = f_mkfs(FATFS_PATH, &mkfs_parm_st, work, sizeof(work));
#else

        res_flash = FR_OK;
        _fat12_flash_mkfs();

#endif
        if (res_flash == FR_OK) {
            /* 格式化后，先取消挂载 */
            res_flash = f_mount(NULL, FATFS_PATH, 1);

            /* 重新挂载	*/
            res_flash = f_mount(&fat_fs, FATFS_PATH, 1);

        } else {
            debug_printf("mkfs failed\r\n");
        }
    }
    if (res_flash != FR_OK) {
        debug_printf("[error] res_mount = %d\r\n", res_flash);
        return FATFS_FUN_RET_ERR;
    }

    debug_printf("\r\n****** mount successful ******\r\n");
    _drv_init_flag = 1;
    return FATFS_FUN_RET_OK;
}

int hl_drv_fatfs_deinit()
{
    FRESULT res_flash;  //文件操作结果

    if (_drv_init_flag == 0) {
        return FATFS_FUN_RET_ERR;
    }
    res_flash = f_mount(NULL, FATFS_PATH, 1);  //卸载文件系统
    if (res_flash != FR_OK) {
        return FATFS_FUN_RET_ERR;
    }

    _drv_init_flag = 0;
    return FATFS_FUN_RET_OK;
}

int hl_drv_fatfs_open(FIL* fnew, char* filename, uint8_t op_flag)
{
    FRESULT res_flash;  //文件操作结果
    char    path_string[20] = { FATFS_PATH };

    if (_drv_init_flag == 0) {
        debug_printf("[erro] fatfs no init\r\n");
        return FATFS_FUN_RET_ERR;
    }

    strcat(path_string, filename);  //将磁盘路径和文件名称组合成一个文件路径

    res_flash = f_open(fnew, path_string, op_flag);  //只读
    if (res_flash != FR_OK) {
        debug_printf("res_open = %d\r\n", res_flash);
        return FATFS_FUN_RET_ERR;
    }

    return FATFS_FUN_RET_OK;
}

int hl_drv_fatfs_close(FIL* fnew)
{
    if (_drv_init_flag == 0) {
        debug_printf("[erro] fatfs no init\r\n");
        return FATFS_FUN_RET_ERR;
    }
    /* 不再读写，关闭文件 */
    f_close(fnew);

    return FATFS_FUN_RET_OK;
}

int hl_drv_fatfs_read(FIL* fnew, uint8_t* read_buffer, uint32_t data_size)
{
    FRESULT res_flash;  //文件操作结果
    UINT    fnum;       //文件成功读写数量

    if (_drv_init_flag == 0) {
        debug_printf("[erro] fatfs no init\r\n");
        return FATFS_FUN_RET_ERR;
    }

    res_flash = f_read(fnew, read_buffer, data_size, &fnum);
    if (res_flash != FR_OK) {
        return FATFS_FUN_RET_ERR;
    }

    return fnum;
}

#if (FATFS_DRV_WRITE_FUN)
int hl_drv_fatfs_write(FIL* fnew, uint8_t* read_buffer, uint32_t data_size)
{
    UINT    fnum;       //文件成功读写数量
    FRESULT res_flash;  //文件操作结果

    if (_drv_init_flag == 0) {
        debug_printf("[erro] fatfs no init\r\n");
        return FATFS_FUN_RET_ERR;
    }

    /* 将指定存储区内容写入到文件内 */
    res_flash = f_write(&fnew, write_buffer, data_size, &fnum);

    if (res_flash == FR_OK) {
        debug_printf("文件写入成功，写入字节数据：%d\r\n", fnum);
    } else {
        debug_printf("[erro] 文件写入失败, res_flash = %d\r\n", res_flash);
        return FATFS_FUN_RET_ERR;
    }

    return fnum;
}
#endif

int hl_drv_fatfs_del_file(char* filename)
{
    FRESULT res_flash;  //文件操作结果
    char    path_string[20] = { FATFS_PATH };

    if (_drv_init_flag == 0) {
        debug_printf("[erro] fatfs no init\r\n");
        return FATFS_FUN_RET_ERR;
    }

    strcat(path_string, filename);  //将磁盘路径和文件名称组合成一个文件路径

    res_flash = f_unlink(path_string);
    debug_printf("unlink ret = %d\r\n", res_flash);
    if (res_flash != FR_OK) {
        return FATFS_FUN_RET_ERR;
    }

    return FATFS_FUN_RET_OK;
}

int hl_drv_fatfs_get_file_size(char* filename)
{
    FRESULT res_flash;  //文件操作结果
    FILINFO file_info;  //文件信息结构体
    char    path_string[20] = { FATFS_PATH };

    if (_drv_init_flag == 0) {
        debug_printf("[erro] fatfs no init\r\n");
        return FATFS_FUN_RET_ERR;
    }
    strcat(path_string, filename);  //将磁盘路径和文件名称组合成一个文件路径

    res_flash = f_stat(filename, &file_info);
    debug_printf("f_stat ret = %d\r\n", res_flash);
    if (res_flash != FR_OK) {
        return FATFS_FUN_RET_ERR;
    }

    return file_info.fsize;
}

/*
 * EOF
 */